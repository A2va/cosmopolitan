/*-*- mode:c;indent-tabs-mode:nil;c-basic-offset:2;tab-width:8;coding:utf-8 -*-│
│ vi: set et ft=c ts=2 sts=2 sw=2 fenc=utf-8                               :vi │
╞══════════════════════════════════════════════════════════════════════════════╡
│ Copyright 2020 Justine Alexandra Roberts Tunney                              │
│                                                                              │
│ Permission to use, copy, modify, and/or distribute this software for         │
│ any purpose with or without fee is hereby granted, provided that the         │
│ above copyright notice and this permission notice appear in all copies.      │
│                                                                              │
│ THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL                │
│ WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED                │
│ WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE             │
│ AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL         │
│ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR        │
│ PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER               │
│ TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR             │
│ PERFORMANCE OF THIS SOFTWARE.                                                │
╚─────────────────────────────────────────────────────────────────────────────*/
#include "libc/assert.h"
#include "libc/calls/calls.h"
#include "libc/calls/internal.h"
#include "libc/calls/sig.internal.h"
#include "libc/calls/struct/sigset.internal.h"
#include "libc/calls/syscall-nt.internal.h"
#include "libc/errno.h"
#include "libc/fmt/itoa.h"
#include "libc/intrin/dll.h"
#include "libc/intrin/fds.h"
#include "libc/intrin/kprintf.h"
#include "libc/intrin/strace.h"
#include "libc/mem/mem.h"
#include "libc/nt/accounting.h"
#include "libc/nt/enum/processaccess.h"
#include "libc/nt/enum/startf.h"
#include "libc/nt/enum/status.h"
#include "libc/nt/errors.h"
#include "libc/nt/files.h"
#include "libc/nt/process.h"
#include "libc/nt/runtime.h"
#include "libc/nt/struct/processinformation.h"
#include "libc/nt/struct/startupinfo.h"
#include "libc/nt/synchronization.h"
#include "libc/nt/thread.h"
#include "libc/nt/thunk/msabi.h"
#include "libc/proc/describefds.internal.h"
#include "libc/proc/ntspawn.h"
#include "libc/runtime/internal.h"
#include "libc/str/str.h"
#include "libc/sysv/consts/at.h"
#include "libc/sysv/consts/o.h"
#include "libc/sysv/consts/sig.h"
#include "libc/sysv/errfuns.h"
#include "libc/thread/posixthread.internal.h"
#include "libc/thread/thread.h"
#ifdef __x86_64__

__msabi extern typeof(CloseHandle) *const __imp_CloseHandle;
__msabi extern typeof(TerminateProcess) *const __imp_TerminateProcess;

extern pthread_mutex_t __sig_worker_lock;

static void sys_execve_nt_abort(sigset_t sigmask) {
  _pthread_unlock();
  _pthread_mutex_unlock(&__sig_worker_lock);
  __sig_unblock(sigmask);
}

textwindows int sys_execve_nt(const char *program, char *const argv[],
                              char *const envp[]) {

  // execve() needs to be @asyncsignalsafe
  sigset_t sigmask = __sig_block();
  STRACE("execve step #1");
  _pthread_mutex_lock(&__sig_worker_lock);  // order matters
  STRACE("execve step #2");
  _pthread_lock();  // order matters
  STRACE("execve step #3");

  // new process should be a child of our parent
  int64_t hParentProcess =
      sys_getppid_nt_win32
          ? OpenProcess(kNtProcessDupHandle | kNtProcessCreateProcess, false,
                        sys_getppid_nt_win32)
          : 0;

  STRACE("execve step #4");

  // inherit pid
  char pidvar[11 + 21];
  FormatUint64(stpcpy(pidvar, "_COSMO_PID="), __pid);

  // inherit signal mask
  char maskvar[6 + 21];
  FormatUint64(stpcpy(maskvar, "_MASK="), sigmask);

  // inherit parent process id
  char ppidvar[12 + 21 + 1 + 21 + 1], *p = ppidvar;
  p = stpcpy(p, "_COSMO_PPID=");
  if (hParentProcess) {
    p = FormatUint64(p, sys_getppid_nt_win32);
    *p++ = ':';
    p = FormatUint64(p, __pid);
    setenv("_COSMO_PPID", ppidvar, true);
  }

  STRACE("execve step #5");

  // define stdio handles for the spawned subprocess
  struct NtStartupInfo si = {
      .cb = sizeof(struct NtStartupInfo),
      .dwFlags = kNtStartfUsestdhandles,
  };
  for (int fd = 0; fd < 3; ++fd) {
    if (!__is_cloexec(g_fds.p + fd)) {
      si.stdiofds[fd] = g_fds.p[fd].handle;
    } else {
      si.stdiofds[fd] = -1;
    }
  }

  STRACE("execve step #6");

  // which process is responsible for spawning the child?
  int64_t hCreatorProcess;
  if (hParentProcess) {
    hCreatorProcess = hParentProcess;
  } else {
    hCreatorProcess = GetCurrentProcess();
  }

  // pass serialized file descriptor table in environment
  char *fdspec;
  int64_t *lpExplicitHandles;
  uint32_t dwExplicitHandleCount;
  if (!(fdspec = __describe_fds(g_fds.p, g_fds.n, &si, hCreatorProcess,
                                &lpExplicitHandles, &dwExplicitHandleCount))) {
    if (hParentProcess)
      __imp_CloseHandle(hParentProcess);
    sys_execve_nt_abort(sigmask);
    return -1;
  }

  STRACE("execve step #7");

  // inherit pending signals
  atomic_fetch_or_explicit(
      __sig.process,
      atomic_load_explicit(&__get_tls()->tib_sigpending, memory_order_acquire),
      memory_order_release);

  STRACE("execve step #8");

  // launch the process
  struct NtProcessInformation pi;
  int rc = ntspawn(&(struct NtSpawnArgs){
      AT_FDCWD, program, argv, envp,
      (char *[]){fdspec, maskvar, pidvar, ppidvar, 0}, 0, 0, hCreatorProcess,
      lpExplicitHandles, dwExplicitHandleCount, &si, &pi});
  STRACE("execve step #9");
  __undescribe_fds(hCreatorProcess, lpExplicitHandles, dwExplicitHandleCount);
  STRACE("execve step #10");
  if (rc == -1) {
    free(fdspec);
    if (hParentProcess)
      __imp_CloseHandle(hParentProcess);
    sys_execve_nt_abort(sigmask);
    if (GetLastError() == kNtErrorSharingViolation) {
      return etxtbsy();
    } else {
      return -1;
    }
  }

  // check if parent spoofing worked
  if (hParentProcess) {
    // give child to libc/proc/proc.c worker thread in parent
    int64_t handle;
    if (DuplicateHandle(GetCurrentProcess(), pi.hProcess, hParentProcess,
                        &handle, 0, false, kNtDuplicateSameAccess)) {
      STRACE("execve step #11");
      unassert(!(handle & 0xFFFFFFFFFF000000));
      __imp_TerminateProcess(-1, 0x23000000u | handle);
    } else {
      STRACE("execve step #12");
      // TODO(jart): Why does `make loc` print this?
      // kprintf("DuplicateHandle failed w/ %d\n", GetLastError());
      __imp_TerminateProcess(-1, ECHILD);
    }
    __builtin_unreachable();
  }

  // we couldn't reparent the new process
  STRACE("warning: execve() lingering due to non-cosmo parent process");

  // terminate other threads
  struct Dll *e;
  struct PosixThread *me = _pthread_self();
  for (e = dll_first(_pthread_list); e; e = dll_next(_pthread_list, e)) {
    struct PosixThread *pt = POSIXTHREAD_CONTAINER(e);
    if (pt == me)
      continue;
    TerminateThread(
        atomic_load_explicit(&pt->tib->tib_syshand, memory_order_relaxed),
        SIGKILL);
  }

  // wait for child to terminate and propagate exit code
  for (;;) {
    uint32_t status;
    WaitForSingleObject(pi.hProcess, -1u);
    GetExitCodeProcess(pi.hProcess, &status);
    if (status != kNtStillActive) {
      if ((status & 0xFF000000u) == 0x23000000u) {
        // handle child execve()
        __imp_CloseHandle(pi.hProcess);
        pi.hProcess = status & 0x00FFFFFF;
      } else {
        // handle child _Exit()
        if (status == 0xc9af3d51u)
          status = kNtStillActive;
        TerminateThisProcess(status);
      }
    }
  }
}

#endif /* __x86_64__ */
